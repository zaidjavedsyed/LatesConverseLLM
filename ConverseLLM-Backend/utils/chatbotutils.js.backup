//const fs = require('fs/promises');
const path = require('path');
const dotenv = require('dotenv');
var cors = require('cors')

dotenv.config();
const { compile } = require("html-to-text");
//const { HierarchicalNSW } = require("hnswlib-node");

const { RecursiveUrlLoader } = require("langchain/document_loaders/web/recursive_url");
//const { HNSWLib } = require('langchain/vectorstores/hnswlib');

const { RetrievalQAChain } = require('langchain/chains');
const { GoogleGenerativeAIEmbeddings } = require('@langchain/google-genai');
const { ChatGoogleGenerativeAI } = require('@langchain/google-genai');
//supabase imports
const { SupabaseVectorStore } = require("langchain/vectorstores/supabase");
const { createClient } = require("@supabase/supabase-js");
const { RecursiveCharacterTextSplitter } = require('langchain/text_splitter');


//const url = "https://daywiseai.com"
//const VECTOR_STORE_PATH = `vector/${removeProtocol(url)}.index`;
const privateKey = process.env.PUBLIC_SUPABASE_PRIVATE_KEY;
    if (!privateKey) throw new Error(`Expected env var SUPABASE_PRIVATE_KEY`);
    const supabase_url = process.env.PUBLIC_SUPABASE_URL;
    if (!supabase_url) throw new Error(`Expected env var SUPABASE_URL`);
    const client = createClient(supabase_url, privateKey);

const model = new ChatGoogleGenerativeAI({
  model: "gemini-2.0-flash-exp",
  temperature: 0.7,
});
console.log('Google API Key (first 10 chars):', process.env.GOOGLE_API_KEY?.substring(0, 10) + '...');


async function createChatBot(url,prompt){
    //let vectorStore;
    //supabase client
    // const privateKey = process.env.PUBLIC_SUPABASE_PRIVATE_KEY;
    // if (!privateKey) throw new Error(`Expected env var SUPABASE_PRIVATE_KEY`);
    // const supabase_url = process.env.PUBLIC_SUPABASE_URL;
    // if (!supabase_url) throw new Error(`Expected env var SUPABASE_URL`);
    // const client = createClient(supabase_url, privateKey);
   // console.log('In createChatBot func');
    const url_to_check = `${removeProtocol(url)}`;
    const fileExists = await checkFileExists(url_to_check);
    if(fileExists){
        console.log('Vector Exists, using existing embeddings');
        const embeddings = new GoogleGenerativeAIEmbeddings({
            model: "text-embedding-004",
            apiKey: process.env.GOOGLE_API_KEY,
        });
        
        const vectorStore = new SupabaseVectorStore(embeddings, {
            client,
            tableName: "documents",
            queryName: "match_documents",
        });
        
        console.log("Using existing vector store for URL:", url_to_check);
        const res = await processPrompt(model,vectorStore,prompt,url);
        console.log("this is response in if=>",res);
        return res;
    }
    else{
      //  console.log("Creating Vector Store..");
        const compiledConvert = compile({
            wordwrap: 130,
            preserveNewlines: true,
            longWordSplit: { wrapCharacters: ['/', '-'] },
            selectors: [
                { selector: 'script', format: 'skip' },
                { selector: 'style', format: 'skip' },
                { selector: 'nav', format: 'skip' },
                { selector: 'header', format: 'skip' },
                { selector: 'footer', format: 'skip' },
                { selector: '.product-card', format: 'block' },
                { selector: '.product-item', format: 'block' },
                { selector: '.price', format: 'block' },
                { selector: '.product-title', format: 'block' },
                { selector: '.product-description', format: 'block' },
                { selector: '.testimonial', format: 'block' },
                { selector: '.review', format: 'block' },
                { selector: 'main', format: 'block' },
                { selector: 'article', format: 'block' },
                { selector: '.content', format: 'block' }
            ]
        });
        
        // Use Playwright for JavaScript-heavy sites like e-commerce
        let loader;
        if (url.includes('shop') || url.includes('store') || url.includes('ecommerce') || url.includes('products') || url.includes('collections')) {
            try {
                const { PlaywrightWebBaseLoader } = require('langchain/document_loaders/web/playwright');
                console.log('Using Playwright loader for JS-rendered pages');
                loader = new PlaywrightWebBaseLoader(url, {
                    launchOptions: { 
                        headless: true,
                        args: ['--no-sandbox', '--disable-setuid-sandbox']
                    },
                    extractor: compiledConvert,
                    waitUntil: 'networkidle',
                    maxDepth: 4,
                    maxPages: 50,
                    gotoOptions: {
                        waitUntil: 'networkidle',
                        timeout: 45000
                    }
                });
            } catch (err) {
                console.warn('Playwright failed, falling back to RecursiveUrlLoader:', err.message);
                loader = new RecursiveUrlLoader(url, {
                    extractor: compiledConvert,
                    maxDepth: 3,
                    excludeDirs: ["/admin", "/login", "/register", "/checkout", "/cart"]
                });
            }
        } else {
            loader = new RecursiveUrlLoader(url, {
                extractor: compiledConvert,
                maxDepth: 4,
                excludeDirs: ["/admin", "/login", "/register", "/checkout", "/cart"]
            });
        }
        const vecdocs = await loader.load();
        console.log(`Loaded ${vecdocs.length} pages from ${url}`);
        
        // Use all pages, not just the first one
        const vecdocsArray = vecdocs.map(doc => doc.pageContent);
        //console.log("vecdocs..",vecdocs)
        const textSplitter = new RecursiveCharacterTextSplitter({
            chunkSize: 1500,
            chunkOverlap: 300,
            separators: ["\n\n", "\n", ". ", "! ", "? ", " ", ""]
          });
          const docs = await textSplitter.createDocuments(vecdocsArray);

          
          const vectorStore = new SupabaseVectorStore(new GoogleGenerativeAIEmbeddings({
  model: "text-embedding-004",
}), {
            client,
            tableName: "documents",
          });
          const website_url = `${removeProtocol(url)}`;
       //   console.log("vectorstore...",vectorStore);
          docs[0].metadata={"url":website_url};
         const ids =  await vectorStore.addDocuments(docs);
         //console.log("This are ids: ",ids);
         const res = await processPrompt(model,vectorStore,prompt,url);
        //console.log("this is response in else =>",res);
          return res;
    }
}


async function generateChatBot(url){
   // console.log('In generateChatBot func');
    const url_to_check = `${removeProtocol(url)}`;
    const fileExists = await checkFileExists(url_to_check);
    if(fileExists){
      //  console.log('Vector Store Exists..');
        const vectorStore = await SupabaseVectorStore.fromExistingIndex(new GoogleGenerativeAIEmbeddings({
  model: "text-embedding-004",
}),{
            client,
            tableName: "documents",
          });
        //console.log("this is vectorStore",vectorStore)
        //const res = processPrompt(model,vectorStore,prompt);
        //console.log("this is response in if=>",res)
        return "Already created";

    }
    else{
       // console.log("Creating Vector Store..");
        const compiledConvert = compile({
            wordwrap: 130,
            preserveNewlines: true,
            longWordSplit: { wrapCharacters: ['/', '-'] },
            selectors: [
                { selector: 'script', format: 'skip' },
                { selector: 'style', format: 'skip' },
                { selector: 'nav', format: 'skip' },
                { selector: 'header', format: 'skip' },
                { selector: 'footer', format: 'skip' },
                { selector: '.product-card', format: 'block' },
                { selector: '.product-item', format: 'block' },
                { selector: '.price', format: 'block' },
                { selector: '.product-title', format: 'block' },
                { selector: '.product-description', format: 'block' },
                { selector: '.testimonial', format: 'block' },
                { selector: '.review', format: 'block' },
                { selector: 'main', format: 'block' },
                { selector: 'article', format: 'block' },
                { selector: '.content', format: 'block' }
            ]
        });
        
        // Use Playwright for JavaScript-heavy sites like e-commerce
        let loader;
        if (url.includes('shop') || url.includes('store') || url.includes('ecommerce') || url.includes('products') || url.includes('collections')) {
            try {
                const { PlaywrightWebBaseLoader } = require('langchain/document_loaders/web/playwright');
                console.log('Using Playwright loader for JS-rendered pages');
                loader = new PlaywrightWebBaseLoader(url, {
                    launchOptions: { 
                        headless: true,
                        args: ['--no-sandbox', '--disable-setuid-sandbox']
                    },
                    extractor: compiledConvert,
                    waitUntil: 'networkidle',
                    maxDepth: 4,
                    maxPages: 50,
                    gotoOptions: {
                        waitUntil: 'networkidle',
                        timeout: 45000
                    }
                });
            } catch (err) {
                console.warn('Playwright failed, falling back to RecursiveUrlLoader:', err.message);
                loader = new RecursiveUrlLoader(url, {
                    extractor: compiledConvert,
                    maxDepth: 3,
                    excludeDirs: ["/admin", "/login", "/register", "/checkout", "/cart"]
                });
            }
        } else {
            loader = new RecursiveUrlLoader(url, {
                extractor: compiledConvert,
                maxDepth: 4,
                excludeDirs: ["/admin", "/login", "/register", "/checkout", "/cart"]
            });
        }
        const vecdocs = await loader.load();
        console.log(`Loaded ${vecdocs.length} pages from ${url}`);
        
        // Use all pages, not just the first one
        const vecdocsArray = vecdocs.map(doc => doc.pageContent);
        //console.log("vecdocs..",vecdocs)
        const textSplitter = new RecursiveCharacterTextSplitter({
            chunkSize: 1500,
            chunkOverlap: 300,
            separators: ["\n\n", "\n", ". ", "! ", "? ", " ", ""]
          });
          const docs = await textSplitter.createDocuments(vecdocsArray);
          const vectorStore = new SupabaseVectorStore(new GoogleGenerativeAIEmbeddings({
  model: "text-embedding-004",
}), {
            client,
            tableName: "documents",
          });
          const website_url = `${removeProtocol(url)}`;
          console.log("Adding", docs.length, "documents to vector store for URL:", website_url);
          
          docs.forEach((entry, index) => {
            docs[index].metadata ={"url":website_url}          
            });
          
          try {
            const ids = await vectorStore.addDocuments(docs);
            console.log("Successfully added", ids.length, "documents with IDs:", ids);
            return "Successfully created";
          } catch (error) {
            console.error("Error adding documents to vector store:", error);
            return `Error: ${error.message}`;
          }
    }
}
// router.get('/', async (req, res) => {
//     try {
//       console.log(" Supabase query==>");
//       const { data: Shoes, error } = await sql.from('Shoes').select('*')
    
//       console.log("Data:", Shoes);
//       if (error) {
//         console.log("Error:", error);
//         return res.status(500).send({ error });
//       }
//       return res.send(Shoes);
//     } catch (error) {
//       console.log("Catch block error:", error);
//       return res.status(500).send({ error });
//     }
//   });
  


async function processPrompt(model, vectorStore, prompt, websiteUrl = null) {
    try {
        console.log('In try... processing prompt');
        console.log('Website URL context:', websiteUrl);
        
        // Enhanced similarity search with URL filtering
        let docs = [];
        
        // Use hybrid search for better results
        docs = await hybridSearch(vectorStore, prompt, websiteUrl, 10);
        
        // If no results and we have a website URL, try broader search
        if (docs.length === 0 && websiteUrl) {
            console.log('No specific results found, trying broader search within website...');
            const broaderDocs = await hybridSearch(vectorStore, "product price cost", websiteUrl, 15);
            docs = broaderDocs.slice(0, 5);
            console.log('Broader search within website found', docs.length, 'documents');
        }
        
        if (docs.length === 0) {
            console.log('No relevant documents found for prompt:', prompt);
            return "I don't have information about that topic in my knowledge base.";
        }
        
        // Enhanced context creation with better ranking
        const context = docs.map((doc, index) => {
            const relevanceScore = doc.relevanceScore || calculateRelevanceScore(doc.pageContent, prompt);
            const source = doc.metadata?.url || 'Unknown source';
            return `[Source ${index + 1}: ${source}, Relevance: ${relevanceScore.toFixed(2)}]\n${doc.pageContent}`;
        }).join('\n\n');
        
        console.log('Context length:', context.length, 'characters');
        console.log('Context preview:', context.substring(0, 300) + '...');
        
        // Enhanced prompt with better instructions
        const { GoogleGenerativeAI } = require('@google/generative-ai');
        const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);
        const geminiModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
        
        const promptText = `You are a helpful assistant that answers questions based ONLY on the provided context from ${websiteUrl || 'the knowledge base'}. 

IMPORTANT RULES:
- Answer ONLY using information from the context below
- If the information is not in the context, say "I don't have that information in the provided context"
- Do NOT make up or guess any information
- Do NOT use your general knowledge to fill gaps
- Focus on specific details like prices, product names, and exact information
- If asked about products, look for specific product names, prices, and descriptions

Question: ${prompt}

Context from ${websiteUrl || 'knowledge base'}:
${context}

Answer based strictly on the context above:`;
        
        const result = await geminiModel.generateContent(promptText);
        const response = await result.response;
        const text = response.text();
        
        console.log('Gemini response generated');
        return text;
        
    } catch (error) {
        console.log('In catch... processing prompt failed');
        console.log("Error details:", error.message);
        return `Error: ${error.message}`;
    }
}

// Helper function to calculate relevance score
function calculateRelevanceScore(content, query) {
    const queryWords = query.toLowerCase().split(/\s+/);
    const contentLower = content.toLowerCase();
    
    let score = 0;
    queryWords.forEach(word => {
        if (contentLower.includes(word)) {
            score += 1;
            // Bonus for exact phrase matches
            if (contentLower.includes(query.toLowerCase())) {
                score += 2;
            }
        }
    });
    
    return score / queryWords.length;
}

// Hybrid search function combining semantic and keyword search
async function hybridSearch(vectorStore, query, websiteUrl = null, k = 10) {
    try {
        console.log('Performing hybrid search for:', query);
        
        // Semantic search
        const semanticDocs = await vectorStore.similaritySearch(query, k);
        console.log('Semantic search found', semanticDocs.length, 'documents');
        
        // Keyword search simulation (filtering by keyword presence)
        const keywordDocs = semanticDocs.filter(doc => {
            const content = doc.pageContent.toLowerCase();
            const queryWords = query.toLowerCase().split(/\s+/);
            return queryWords.some(word => content.includes(word));
        });
        console.log('Keyword filtering found', keywordDocs.length, 'documents');
        
        // Filter by website if provided
        let filteredDocs = keywordDocs;
        if (websiteUrl) {
            const urlToCheck = removeProtocol(websiteUrl);
            filteredDocs = keywordDocs.filter(doc => 
                doc.metadata && 
                doc.metadata.url && 
                doc.metadata.url.includes(urlToCheck)
            );
            console.log('After website filtering:', filteredDocs.length, 'documents');
        }
        
        // Rank by relevance score
        const rankedDocs = filteredDocs.map(doc => ({
            ...doc,
            relevanceScore: calculateRelevanceScore(doc.pageContent, query)
        })).sort((a, b) => b.relevanceScore - a.relevanceScore);
        
        console.log('Final ranked results:', rankedDocs.length, 'documents');
        return rankedDocs;
        
    } catch (error) {
        console.log('Hybrid search error:', error);
        return [];
    }
}

// async function chatBotPrompt(prompt){
//     try{
//         const vectorStore = await HNSWLib.load(VECTOR_STORE_PATH,new OpenAIEmbeddings());
//         const chain = RetrievalQAChain.fromLLM(model,vectorStore.asRetriever());
//         const response = await chain.call({
//             query:prompt,
//         })
//         console.log(response);
//     }catch{
//         console.log("Unexpected error occur");
//         //return error;
//     }
// }

async function removeEmbeddings(url){
  const urlToCheck = `${removeProtocol(url)}`;
    try{
        console.log("in try... checking if vector exist to delete")
     //   console.log("supabase query to find..",urlToCheck)
        var {data,error}=await client.from('documents').select(`id,metadata->url`);
      //  console.log("total data",data);

        data = data.filter(e=>e.url==urlToCheck);
       // console.log("SSS",data);
        var indices = [];
        data.forEach(e=>{indices.push(e.id)})
      //  console.log("Indices of entries..",indices)
     //   console.log("this is final data..",data)
        

        if(error){
            console.error("supabase error to find..",error);
            return false;
        }
        const urlExists = indices.length>0;
        const noOfEmbeddings = indices.length;

        //await fs.access(filePath);
        if(!urlExists)return "No embeddings found";
      //console.log("this is urlExists",urlExists);
       
      const vectorStore = await SupabaseVectorStore.fromExistingIndex(new GoogleGenerativeAIEmbeddings({
  model: "text-embedding-004",
}),{
        client,
        tableName: "documents",
      });
        // Convert indices to strings or numbers, depending on your use case
        //const stringIndices = indices.map(index => String(index));
        const numberIndices = indices.map(index => Number(index));

        await vectorStore.delete({ ids: numberIndices });
        // or await vectorStore.delete({ ids: numberIndices });
      //await vectorStore.delete({indices})
   //   console.log("deleted successfully",noOfEmbeddings);
      return ("Deleted Embeddings sucessfully");
        
    }catch(error){
        console.log("in catch... no vector to delete "+error)
        return "Unable to delete embeddings";
    }
      
}

async function updateEmbeddings(url){
  const url_to_check = `${removeProtocol(url)}`;
  const fileExists = await checkFileExists(url_to_check);
    if(fileExists){
      console.log("found embeddings to Update");
    try {
      console.log("calling remove embeddings");
      await removeEmbeddings(url);
      console.log("calling generate chatbot");
      try{
      await generateChatBot(url);
      console.log("Updated embeddings");
      return "Embeddings successfully updated";
      }
      catch(error){
        console.log("Error while regenrating embeddings");
      }
    } catch (error) {
      console.error("Error updating embeddings:", error);
      return "Error: Unable to update embeddings";
  }
  }
  else{
    console.log("No embeddings found to update");
    return "No Embeddings found to Update"
  }
}


function removeProtocol(url) {
  // Remove "http://" or "https://", if present
  console.log('In remove protocol...');
  return url.replace(/^https?:\/\//, '');
}


async function checkFileExists(urlToCheck){
  try{
     // console.log("in try... checking if file exist")
      //console.log("supabase query..",urlToCheck)
      var {data,error}=await client.from('documents').select('metadata');
     // console.log(data);

      data = data ? data.filter(e=>e.metadata.url==urlToCheck) : [];
     // console.log("SSS",data);

      if(error){
          console.error("supabase error to find..",error);
          return false;
      }
      const urlExists = data && data.length>0;
      //await fs.access(filePath);
    //console.log("this is urlExists",urlExists);
      return urlExists;
  }catch(error){
      console.log("in catch... no file found "+error)
      return false;
  }
}
//createChatBot("https://daywiseai.com","How does daywiseai help us?");
//chatBotPrompt("https://daywiseai.com","how can daywiseai can help me?");
//removeEmbeddings("skippi.in/");
//updateEmbeddings(url,VECTOR_STORE_PATH);
// New function for workspace-specific queries
async function processWorkspaceQuery(workspaceId, prompt, websiteUrl = null) {
    try {
        console.log('Processing workspace query for:', workspaceId);
        
        const embeddings = new GoogleGenerativeAIEmbeddings({
            model: "text-embedding-004",
            apiKey: process.env.GOOGLE_API_KEY,
        });
        
        const vectorStore = new SupabaseVectorStore(embeddings, {
            client,
            tableName: "documents",
            queryName: "match_documents",
        });
        
        // Enhanced search with workspace filtering
        let docs = [];
        
        if (websiteUrl) {
            // Search within specific website
            docs = await vectorStore.similaritySearch(prompt, 15);
            const urlToCheck = removeProtocol(websiteUrl);
            docs = docs.filter(doc => 
                doc.metadata && 
                doc.metadata.url && 
                doc.metadata.url.includes(urlToCheck)
            );
        } else {
            // Search within workspace (all websites in workspace)
            docs = await vectorStore.similaritySearch(prompt, 10);
            // For now, we'll use all results, but in future we can filter by workspace metadata
        }
        
        if (docs.length === 0) {
            return "I don't have information about that topic in this workspace.";
        }
        
        // Enhanced context with source information
        const context = docs.map((doc, index) => {
            const source = doc.metadata?.url || 'Unknown source';
            const relevanceScore = calculateRelevanceScore(doc.pageContent, prompt);
            return `[Source ${index + 1}: ${source}, Relevance: ${relevanceScore.toFixed(2)}]\n${doc.pageContent}`;
        }).join('\n\n');
        
        // Enhanced prompt for workspace context
        const { GoogleGenerativeAI } = require('@google/generative-ai');
        const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);
        const geminiModel = genAI.getGenerativeModel({ model: "gemini-2.0-flash-exp" });
        
        const promptText = `You are a helpful assistant answering questions within workspace: ${workspaceId}.

IMPORTANT RULES:
- Answer ONLY using information from the context below
- If the information is not in the context, say "I don't have that information in this workspace"
- Do NOT make up or guess any information
- Focus on specific details like prices, product names, and exact information
- If asked about products, look for specific product names, prices, and descriptions
- Consider the source of information when answering

Question: ${prompt}

Context from workspace ${workspaceId}:
${context}

Answer based strictly on the context above:`;
        
        const result = await geminiModel.generateContent(promptText);
        const response = await result.response;
        const text = response.text();
        
        console.log('Workspace query response generated');
        return text;
        
    } catch (error) {
        console.log('Workspace query error:', error);
        return `Error processing workspace query: ${error.message}`;
    }
}

module.exports={generateChatBot,createChatBot,removeEmbeddings,updateEmbeddings,processWorkspaceQuery,hybridSearch}


async function generateEmbeddings(text, project_id) {
    const textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: 800,
      chunkOverlap: 200,
    });
    const documents = await textSplitter.createDocuments([text]);
   // console.log(documents);

    const content = documents.map((doc) => doc.pageContent).join('\n');
    const metadata = { project_id : project_id };
    const docs = [new Document({ pageContent: content, metadata })];
    
    let vectorStore = await SupabaseVectorStore.fromDocuments(
      docs,
      new OpenAIEmbeddings(),
      {
        client: SUPABASE_CLIENT,
        tableName: 'documents',
      }
    );
  }
  
const run = async () => {
    
    const embeddings = new OpenAIEmbeddings();
  
    const store = new SupabaseVectorStore(embeddings, {
      client,
      tableName: "documents",
    });
  
    const docs = [
      { pageContent: "hello", metadata: { b: 1, c: 9, stuff: "right" } },
      { pageContent: "hello", metadata: { b: 1, c: 9, stuff: "wrong" } },
    ];
  
    // Also takes an additional {ids: []} parameter for upsertion
    const ids = await store.addDocuments(docs);
  
    const resultA = await store.similaritySearch("hello", 2);
   // console.log(resultA);
  
    /*
      [
        Document { pageContent: "hello", metadata: { b: 1, c: 9, stuff: "right" } },
        Document { pageContent: "hello", metadata: { b: 1, c: 9, stuff: "wrong" } },
      ]
    */
  
    await store.delete({ ids });
  
    const resultB = await store.similaritySearch("hello", 2);
    //console.log(resultB);
  
    /*
      []
    */
  };
  //run();